--- 
layout: post
title: How to build DLC pipelines that don't suck
date: 2013-05-16 09:27:22
authors: 
- usman
categories: 
- System Design
tags:
- games
- dlc
- s3
- cloudfront
permalink: /dlchowto
---

The gaming industry has entered a brave new world where the first launch is just the start. Games are now services that need to be maintained for years. During this time you will need to make frequent content updates to keep users engaged. This is where a good DLC pipeline is invaluable and bad one can kill the best of games. I have built, worked on and worked with a number of such pipelines including  [Pogo](https://itunes.apple.com/us/app/id373416293), [World Series of Poker](https://itunes.apple.com/us/app/world-series-of-poker/id458792705), [The Simpsons Tapped Out](https://itunes.apple.com/us/app/the-simpsons-tapped-out/id497595276) and a few others that will not be named. These pipelines range from; simple and effective (Poker) to complicated but effective (Simpsons and Pogo), and complicated and a pain in the ass (Unnamed). This article discusses some lessons learnt and good process to follow and some bad ones to avoid like the plague. 
{% image /assets/images/simpsons_to_normal.jpg style="float:right" alt="Simpsons Tapped Out" class="pimage" %}

### What makes a DLC pipeline not suck?

Before we delve into how to build DLC pipelines that do not suck lets take a quick look at what a DLC pipeline should do and look like;

1. __Content Updates without client updates:__
A DLC pipeline provides a way for games' look and feel to be changed without a client update There are a number of reasons to avoid client updates, chiefly among them users are fickle and requiring updates before they see new content defeats the purpose of increasing engagement using content updates. 


1. __Support for both permanent and short-term content updates:__
Content updates come in two forms; permanents updates or additions to the game such as new purchasable items and temporary skins on all or many items for seasonal themes or sales. A DLC pipeline should support easy update of assets as well as the concept of temporary changes that can be rolled back easily without impacting the permanent changes. 

1. __Testability:__
One requirement on content pipelines that people often for get is that Developers, Artists and Designers will all be testing changes to various assets concurrently. There should be a way for all of these individuals to test their changes without effecting other users. This is especially important to consider from the perspective of Artists and Designers who usually cannot build the game code locally. 

1. __Good Isolation:__
A related requirements is to be able to easily isolate the various environments from each other so that they can be tested independently. Further, developers, artists and designers should be able to test their changes independently of all other changes before committing them to source control.

1. __Support for A/B Testing:__
Lastly, any good mobile/social game needs to iterate and user-test changes. Therefore, any good DLC pipeline needs to support A/B testing. 


{% image /assets/images/simpsons_to_christmas.png style="float:right" alt="Simpsons Tapped Out" class="pimage" %}

### Asset Indexing

Before we start laying out our DLC pipeline we have to be clear about how we think about assets. We must differentiate between an *Asset Concept* and a *Concrete Asset*. For example a "Loading Screen" is an asset concept whereas each of the various Simpsons Tapped Out loading screens you see in this article are Concrecte Assets. This is an important distinction to make and will simplify a lot design decisions down the line and also allow you to formalize rules arround how assets are managed. One of the first and most important rules is that Concepts should be client addressable but concrete assets should not. The client code should ask the asset loader module or library for the background image or loading screen but should never ask for the christmas themed background image. It should be the job of the asset loader to decide which asset to serve in resposne to the request. 

For this reason we always create an index of all our assets, which is essentally a key-value mapping between a concept and its current concrete implementation. The client ships with a base asset index but on every startup asks the server for an updated copy. This way we can select which asset a user actually sees, on a per-user basis, without any client updates. Using this control we can run A/B Tests or temporarily apply a sesonal theme by just updating the index. Once the test or season is over we can revert the index to original state and without ever making any client changes. An example of an asset index is shown below that a client may get from the server is shown below.

{% codeblock Asset Index lang:javascript %}
[
    {
        "concept": "main-loading-screen",
        "concrete-asset": "/assets/image/{resolution}/loading-christmas_2012.png"
    },
    {
        "concept": "kwik-e-mart",
        "concrete-asset": "/assets/image/{resolution}/kwik-e-mart-v2.png"
    },
    {
        "concept": "sale-item-list",
        "concrete-asset": "/assets/config/sale-item-list-test5-alpha.txt"
    }
]
{% endcodeblock %}

### Asset Immutability 

Another reason why we need to sepreate asset concepts from concrete implemntations is so that we can make sure concrete assets are immutable. The loading screen for Simpsons Tapped out may look different from time to time but each concerete implmentation of the concept never changes. For example the image in the  kwik-e-mart-v2.png file will always be identical. There are a number of reasons why its a good idea to have immutable asset files. 

Firstly, once your game has been out for a while there will be a number of different versions of the client in the wild. Users are well known to be ver slow about updating their clients and sometimes may not be able to if their device is too old. If you were rnaming files you would have to ensure each change was compatible with all or most versions of your client still out in the wild. If however, all concrete implementations are immutable than we can make sure old clients get a version of the index that was released for them. Any new asset work will have no impact on deployed clients. 

{% image /assets/images/simpsons_to_valentines.png style="float:right" alt="Simpsons Tapped Out" class="pimage" %}

Secondly, sometimes code-changes and asset changes need to pushed out together. For example lets say you changed the format of the sale-item-list from xml to JSON. Let us assume you have control of client update schedule (for example in a Web/Facebook game) so the problem of out of date clients is not an issue. If you deploy your asset file before your client code your old-client will be broken until its replaced. If you push the client code first it will be broken until the new assets are available. This usually rules out rolling deploments and requires downtime while the deployments are taking place. 

Furthermore, if you use a content delivery network (CDN) such as [Akamai](http://www.akamai.com/) or [CloudFront](http://aws.amazon.com/cloudfront/), you have to wait until the old assets time-out before they are reloaded from the source and the changes are reflected. This timout can be anything from minutes to hours. With immutable files we need ensure that the client is always loading the assets it  supports. This also gives us the added advantage that we can cache assets infintiely. Hence we never download the same asset twice and provide much shorter loading times to users. 

### Asset Branching 

Now we come to the question of where to put assets. In our experience we have always found it better to  put Asset files should be in their own directory/project. The major reason for this requirement is that DLC release schedules are very different from client release schedules and maybe even server release schedules. Mobile client normally release updates on the order of months (or more if the DLC pipeline is working) where as DLC release schedules may be in the order of weeks or even days. DLC releases are often tied to server releases but as we will discuss later if we use a CDN we maybe able to release content without pushing servers. 

{% image /assets/images/simpsons_to_halloween.png style="float:right" alt="Simpsons Tapped Out" class="pimage" %}
### To Pack or Not To Pack?
In several of our projects we have seen the tendency of developers to group assets into a packs of related content and zip them. This comes from a notion that this will lead to better compression and hence lower load times. Another notion is that downloads will be faster with a single large file rather than many small files. Both these assertions are true but in reality will lead to worse perceived load times. For example in the Simpsons Tapped Out, before you play your first game you may have to download almost a hundered megabytes. Most of the assets being downloaded are not needed in my first gameplay session or probably my first dozen gaming sessions. However, since all the assets are in one game pack (or a few packs) I have to download the whole thing. If I lose connectivity during this massive download D'ouh start again. Instead if the game had shipped with the minimal set of assets needed in the first gameplay and then lazy load the rest of the assets I can get into my first gameplay session much faster.  

In addition to making game play slower packed assets also make the development process more cumbersome. We now have an extra step in out DLC pipeline and we have to make sure all artists and client developers can locally pack assets so that they can test their changes before committing them. In addition we have to decide do we repack the assets with every build? This may slow down local builds considerable. Do we upload them somewhere and download them with every build? So no more offline builds. Do we check them into our source control? yikes, generated artifacts in source control. With individual assets we can just check them into source and consume them directly on the local builds. 



### Local testing

### Hosting assets (CDN)

### Environment planning

{% image /assets/images/simpsons_to_thanks.jpg style="float:right" alt="Simpsons Tapped Out" class="pimage" %}





   Summary: No zipping or combining images into one big image